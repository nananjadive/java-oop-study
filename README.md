# java-oop-study
자바프로그래밍 기초 \

참고 코드프레소 -JAVA프로그래밍 개념 초급

## 메소드

객체는 속성과 행위를 갖고 있고, 메소드는 객체의 행위를 정의

메소드는 함수과 거의 유사함  
input와 output이 존재

메소드는 특정 객체에 포함되어 있음  
독립적으로 존재하지 않음

## 함수

특정 작업을 수행  
코드들을듈화 필요한경우 호출  
중복을 줄일 수 있음

동일한 작업의 코드들을 코드로 묶는것

함수는 독립적으로 존재  
객체안에 멤버변수에 대한 연산이가능

## 메소드의 문법

\-메소드를 호출하기 위한 메소드의 이름 존재  
\-특정 작업을 위한 메소드의 구현 코드가 중관호 내부에 구현됨

메소드는 input과 output  
메소드의 이름  
보통 동사 연결되는 단어의 첫글자 댓글자

사용자 클래스에 행동을 추가

## 객체의 메소드를 호출

점 연산자로 객체의 멤버(메소드)에 접근가능  
필요한 경우 메소드의 인자(값)을 전달  
객체참조변수명.메소드명(인자)  
메소드 호출의 결과 값을 리턴 받아 사용가능

메소드는 별도의 데이터(인자)를 전달하지 않아도 객체의 멤버 변수를 활용하여 작업이 가능

사용자 객체의 메소드 호출  
\-메소드는 별도의 데이터(인자)를 전달하지 않아도 객체의 멤버변수를 활용하여 작업이 가능

함수와 다른점  
객체의 메소드는 모든 데이터를 전달하지 않아도 객체의 멤버 변수에 대한 연산이 가능

## 접근제어자

캡슐화  
객체의 속성과 행동을 하나의 단위로 그룹화

### 객체의 속성과 행동을 은닉

반드시 필요한 속성및 행동만 외부에 노출  
대부분의 속성을 외부에서 접근하지 못하도록 막는거

### 객체의 정보 은닉

객체 내부에는 외부에서 접근해서 변경하며 안되는 속성이 존재  
\-사용자 객체의 나이를 -10이나 100으로 변경 한다면?  
\- 사용자 객체의 비밀번호를 변경 한다면?

steve.age = -10;  
steve.password ="iwantyouraccount";

객체의 정보 은닉  
반드시 필요한 멤버만 외부에 노출하여 결합도를 줄일 수 있음

### 객체의 정보 은닉 방법

접근제어자를 활용  
JAVA 접근제어자의 종류  
public private protected default

## 접근 제어자의 사용

클래스 멤버변수 메소드에 활용  
클래스는 calss키워드 앞에 명시  
멤버 변수는 자료형 앞에 명시  
메소드는 리턴 타입 앞에 명시

## private 멤법 변수 값 변경하거나 사용하고 싶을 때

생성자로 객체 멤버 변수 값을 초기화  
setter 메소드로 객체 멤버 변수의 값을 변경  
getter 메소드로 객체 멤버 변수의 값을 사용

\-캡슐화중 정보 은닉은 반드시 필요한 멤버만 적절한 단계로 외부에 노출하고 그 외의 정보는 숨기는 것

\-외부에서 잘못 된 형태로 속성을 변경하여 프로그램에 문제가 생기는 것을 막음

\-객체 간의 관계의 양(결합도)를 조정하여 좋은 설계를 만들 수 있음

\-접근 제어자를 default로 두지 말고 반드시 적절하게 명시해야 함

\-public 멤버는 외부의 모든 곳에서 접근 가능하고, private 멤버는 외부에서 접근 불가

## 메소드의 리턴값과 파라미터

input은 없거나 1개이상의 파라미터 리스트  
output은 없거나 리턴 값으로 표시  
리턴 타입은 리턴 되는 값 자료 형 (리턴 값이 없을 경우 void)

### 메소드 파라미터(매개변수) 활용

파라미터는 메소드의 input 데이터  
없거나 1개이상의 파라미터 존재가능  
메소드 이름 뒤에 위치하며 소관호 내부에 "자료형 변수명" 쌍으로 표현

### 메소드 파라미터(매개변수)의 활용

user객체의 private멤버 변수 email값을 저장하는 메소드 추가

메소드 리턴

메소드 수행 결과를 값으로 반환  
\-return 키워드를 사용하며, return을 만나면 메소드는 값을 반환하고 종료 됨  
\-메소드 내에 1개 이사의 return문 사용가능

### 메소드에 리턴 하는 값의 자료형을 명시해야함

리턴 값이 없는 경우도 존재  
리턴 자료형에 "void" 키워드 사용

## 생성자 (constructor)

\-객체가 생성되는 시점에 호출 되는 특별한 형태의 메소드

\-객체가 생성 되는 시점에 초기화를 하기 위해 사용 됨  
\-주로 생성장에서는 객체 멤버 변수의 초기화 작업을함

## 멤버 변수를 명시적으로 초기화 하지 않는 경우 아래값이 저장 됨

\-숫자형 변수는 0  
\-불리안 변수는 false  
\-참조변수는 null

## 생성자의 문법

생성자의 이름은 클래스의 이름과 동일  
접근 제어자는 보통 public을 사용  
0개 또는 1개이상의 파라미터 선언가능  
리턴 타입은 생략됨

Default 생성자  
생성자를 명시적으로 추가하지 않은 경우 Default 생성자를 제공  
\-1개이상의 생성자를 명시적으로 구현한 경우는 제공하지 않음

Default 생성자 사용의 예  
\-현재까지 사용자 객체에 생성자 존재하지 않음

사용자 객체의 생성자 추가  
user 생성자 추가  
4개의 멤버 변수를 초기화

## 사용자 객체의 생성자 사용

### 파라미터가 있는 생성자

\-모든 변수의 값을 인자로 전달 받아 초기화하는 생성자

객체 생성과 함께 전달하는 인자 값으로 객체의멤버변수를 초기화

### 파라미터가 있는 생성자

멤버 변수의 일부만 초기화 하는 생성자

생성자를 구현하는 경우 Default 생성자는 사용 불가  
Default 생성자는 명시적으로 구현 된 생성자가 없을 경우 에만 제공  
생성자를 구현 한 경우 Default 생성자를 사용할 수 없음

point  
생성자는 객체가 생성될 때 호출 되는 특별한 형태의 메소드  
생성자의 이름은 클래스명과 동일하며 리턴 타입은 사용하지 않음  
생성자는 주로 객체의 멤버 변수를 초기화 하는 목적으로 사용  
생성자를 명시적으로 구현하지 않은 경우 Default생성자 제공  
파라미터가 있는 생성자를 호출하기 위해서는 new키워드로 객체 생성 시인자를 전달해야함

## 메소드 오버로딩

같은 작업을 하지만 파라미터만 다른 메소드가 필요한 경우  
C언어 수학 관련 함수 중 절대 값을 구하는 함수의 종류  
\-abs(),labs(),fabs(),cabs()

### 메소드를 사용할때 동일 작업을 위한 다양한 이름의 메소드를 기억해야함

### 메소드를 개발할 때 파라미터의 조합에 따라 다양한 이름을 생성해야함

\-명확한 동작을 의미하는 것이 아닌 조약한 이름이 만들어질 수 있음

### 특정 클래스 안에서 파라미터가 다른 동일한 이름의 메소드를 선언

파라미터의 자료형 또는 개수가 다르면 동일한 이름 사용 가능  
메소드 호출시 파라미터 세팅 조건에 따라 호출되는 메소드가 결정됨  
리턴 타입은 메소드 오버로딩의 조건에 해당하지 않음

### 메소드 오버로딩

\-public int add(int a, int b)  
\-public int add(int a, int b, int c)  
\-public double add(double a, double b)

## 메소드 오버로딩의 부적합한 예시

\-public int add(int a, int b)  
\-public long add(int a, int b) -리턴타입만 다를경우 오버로딩을 할 수 없다

## 사용자 객체에 메소드 오버로딩 적용

\-성인 여부를 체크하는 메소드를 isAdult로 변경  
\-파라미터가 없을경우 20세를 기준으로함  
\-성인 기준 나이를 파라미터로 받는 메소드 추가

## 생성자 오버로딩

\-생성자도 특수한 형태의 메소드이기 때문에 오버로딩 적용 가능  
\-초기화 원하는 멤버 변수만 선택해서 초기화 가능  
\-생성자 오버로딩은 빈번하게 사용 됨

\-메소드 오버로딩은 서로 다른 조합의 파라미터를 사용하는 동일한 이름의 메소드를 한 클래스 내부에서 사용하는 것

\-의미 있는 메소드의 이름을 여러 메소드 사용할 수 있음

\-메소드 호출 시 세팅하는 파라미터에 따라 어떤 메소드가 호출 될지 결정

\-리턴 타입은 메소드 오버로딩의 조건이 되지 않음

\-생성자도 오버로딩 가능

일반메소드뿐만이아니라 생성자도 서로다른파라미터의 조합에 따라서 오버로딩을 할 수 있다 객체를 생성하는시점에 인자데이터를 호출하는 시점에 서로다른데이터가 호출이 된다
